module eps_matrix {
  include "ckcomplex.h";
  include "CLA_Matrix.h";

  extern module matrix;
  extern module messages;
  extern module psi_cache;

  array [2D] EpsMatrix : Matrix {
    entry EpsMatrix();
    entry EpsMatrix(MatrixConfig config);
    entry void createTranspose(CProxy_EpsMatrix other, bool todo);
    entry void createConjugate(CProxy_EpsMatrix other);
    entry void receiveTranspose(std::vector<complex> incoming);
    entry void receiveConjugate(std::vector<complex> incoming);
    entry void multiply(double alpha, double beta);
    entry void round_done();
    entry void scalar_multiply(double alpha);
    entry void add_compl_two();
    entry void convergence_check(CProxy_EpsMatrix cmp_proxy);
    entry void receiveConvCheck(std::vector<complex> incoming);
    entry void setI(CLA_Matrix_interface mat, bool clean);
    entry void receiveFs(Phase3Message*);
    entry void bareExchange();
    entry void screenedExchange();
    entry void coh();
    entry void findAlpha();
    entry void multiply_coulb();
    
    entry void createCopy(CProxy_EpsMatrix other, bool todo);
    entry void recvCopy(std::vector<complex> new_data);
    entry [sync] DiagMessage* receiveDataSimple(DiagMessage* msg);
    
    
    entry void pdgemmSendInput(CProxy_EpsMatrix output, bool aOrB) {
      serial {
        if (aOrB)
          output(thisIndex.x, (thisIndex.y-thisIndex.x+numBlocks)%numBlocks).inputA(0, data, blockSize, blockSize, thisIndex.x, thisIndex.y);
        else
          output((thisIndex.x-thisIndex.y+numBlocks)%numBlocks, thisIndex.y).inputB(0, data, blockSize, blockSize, thisIndex.x, thisIndex.y);
      }
    };

    entry void pdgemmRun(double alpha, CkCallback done) {
      serial {
        delete [] data;
        initialize();
      }

      forall [block] (0:numBlocks-1,1) {
        when
          inputA[block](int blockIdA, complex blockA[M*KA], unsigned int M, unsigned int KA, int a_index_x, int a_index_y),
          inputB[block](int blockIdB, complex blockB[KB*N], unsigned int KB, unsigned int N, int b_index_x, int b_index_y)
          serial {
          CkAssert(KA == KB);
//          CkPrintf("\n C[%d,%d] received A[%d,%d], B[%d,%d]", thisIndex.x, thisIndex.y, a_index_x, a_index_y, b_index_x, b_index_y);

          // This DGEMM makes no attempt at optimization. For
          // benchmarking, it should be replaced with a library
          // call. The local version is kept for easy portability.
          example_dgemm(M, N, KA,
                        alpha,
                        blockA, blockB, data);
          if (blockIdA != numBlocks) {
            int destX = thisIndex.x;
            int destY = (thisIndex.y + 1) % numBlocks;
            thisProxy(destX, destY).inputA(blockIdA+1, blockA, M, KA, a_index_x, a_index_y);
          }
          if (blockIdB != numBlocks) {
            int destX = (thisIndex.x + 1) % numBlocks;
            int destY = thisIndex.y;
            thisProxy(destX, destY).inputB(blockIdB+1, blockB, KB, N, b_index_x, b_index_y);
          }
        }
      }
      serial {
        contribute(done);
      }
    };
    entry void inputA(int blockIdA, complex blockA[M*KA], unsigned int M, unsigned int KA, int a_index_x, int a_index_y);
    entry void inputB(int blockIdB, complex blockB[KB*N], unsigned int KB, unsigned int N, int b_index_x, int b_index_y);
  };
  // end array EpsMatrix

  group DiagBridge{
    entry DiagBridge();
    entry void prepareData(int qindex, int size, int num_qpts);
    entry void copyToMPI(int qindex, int real_epsilon_size, CProxy_EpsMatrix smatrix_proxy) {
      serial {
        int mype = CkMyPe();
        for (int mat_row = 0; mat_row < numBlocks; mat_row++) {
          for (int mat_col = 0; mat_col < numBlocks; mat_col++) { 
            int dest_pe_row = mat_row%proc_rows;
            int dest_pe_col = mat_col%proc_cols;
            // PE array is row major, hence dest_pe below
            // https://www.netlib.org/scalapack/slug/node70.html
            int dest_pe = dest_pe_row*proc_cols + dest_pe_col;
            
            if (mype == dest_pe) { 
              DiagMessage* msg;
              msg = new DiagMessage();
              msg = smatrix_proxy(mat_row, mat_col).receiveDataSimple(msg);
              // int last = msg->size - 1;
              // double first_val = msg->data[0];
              // double last_val = msg->data[last];
              // CkPrintf("[copyToMPI] x %d y %d last %d first_val %.6e last_val %.6e\n", msg->x , msg->y, last, first_val, last_val);
              int loc_mat_row = (mat_row - dest_pe_row) / proc_rows;
              int loc_mat_col = (mat_col - dest_pe_col) / proc_cols;
              int start_index = ((loc_mat_col * diagData->row_size) + loc_mat_row) * 20;
              // CkPrintf("[bcyclic] loc_x %d loc_y %d mat_row %d mat_col %d start_index %d of %d col size %d\n", loc_mat_row, loc_mat_col, mat_row, mat_col, start_index, diagData->inputsize, diagData->col_size);
              for (int i = 0; i < msg->size; i++) {
                int idx_row = i % msg->rows;
                // int idx_col = i / msg->cols;
                int idx_col = i / msg->rows;
                int bl_cyclic_index = start_index +  idx_col * diagData->row_size + idx_row;
                // CkPrintf("[bcyclic] tot_size %d (%dx%d) row/col %d/%d x %d y %d i %d blc %d\n", diagData->inputsize, diagData->row_size, diagData->col_size, idx_row, idx_col, msg->x , msg->y, i , bl_cyclic_index);
                diagData->input[bl_cyclic_index] = msg->data[i];
              }
              delete msg;
            }
          }
        }
        contribute(CkCallback(CkReductionTarget(Controller, mpi_copy_complete), controller_proxy));
      }
    } // end copyToMPI
    entry void copyFromMPI(int qindex, int real_epsilon_size, CProxy_EpsMatrix smatrix_proxy) {
      serial {
        delete [] diagData->input;
        delete [] diagData->eig_e;
        delete [] diagData->eig_v;
        delete diagData;
      }
    }
  }; // end group DiagBridge
  

};
